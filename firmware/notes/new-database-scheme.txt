New scheme for neighbor lists
2018-08-03 Paul Williamson

RAM cache has minimal information on each badge, only that info needed
to process routine advertisements:
	6-byte BLE address
	11-byte last received name (including null terminator)
	RSSI of last received advertisement (or filtered?)
	time of last reception (ticks since powerup)
	flags (helloed, displayed, maybe others)
That's 23 bytes per entry. 256 entries = 5888 bytes.

All other info is on the SD card in files named with an encoded version
of the BLE address. Not the JoCo encoding with hex, but a more compact
encoding so that each badge gets its own file. There may eventually be
more than one directory containing parallel sets of files, but for now
we just have the QSO directory. The QSO directory contains files
in support of the QSO game. These files are human readable and contain
one or more records detailing the result of each QSO. They look like this:
	QSO at 12345678 rssi -32
	CALLSIGN Name
	Message received from the other badge if there was one.
	Might be multiple lines of message.
	(blank line delimiter)

or
	No QSO at 12345678 rssi -127
	Optional description of the reason for failure
	(blank line delimiter)

This is the same format used in the main QSO log file. The QSO game info file
can then be displayed on the screen using the log file viewer, as if it
had been generated by searching the main QSO log file. If there has been no
attempt at a QSO with this badge, there is no file in the QSO directory.

The RAM cache uses a trick to speed up processing in the typical case.
The least significant byte of the BLE address is used to compute a
starting point in the array. From the starting point, search is linear,
and stops when an empty entry is found, wrapping to the top if necessary. This
is a very basic hash table. We will limit it to 256 entries so we can sort
it with an array of bytes (indexes into the main array).

Note that nothing ever moves in the array. Once a neighbor is written to a spot
in the array, it will be updated in place. If the list fills up completely,
a neighbor can be overwritten. As the list approaches full, performance
degrades but is always better than a simple linear search.

Processing on reception of an advertisement goes like this:
	if updates are frozen (i.e., during sorting), discard and exit.
	validate that the advertisement is a badge (and the main appearance type)
	if it's not, discard and exit.
	get the LS byte of the BLE address as the starting point in array
	search array from starting point until we find a match or a zero.
	if we find a match,
		update RSSI (no need to check old value)
		update name (no need to check old value)
		update last_heard time
		update game info flags
		done.
	if we find a zero,
		initialize record with address and default flags
		proceed as if we found a match.
	if we wrap all the way around and don't find either,
		choose the record with the oldest last_heard_time.
		if the oldest heard time is less than 3 minutes ago,
			discard and exit.
			This is supposed to mitigate the case where more than 256 badges
			are constantly being heard; we just start ignoring new ones so
			we aren't constantly swapping them in and out.
		proceed as if we'd found a zero there.


Displaying a neighbor menu goes like this:
	We want to choose which badges to display in RSSI order, but we don't have
	the database sorted that way. Luckily this can be slow, so we scan the
	array and build a list of badges based on RSSI. Initially, we want the
	highest SCREEN_LINES badges, but if we have scrolled down the display we
	will want some other subrange.

	Menu processing has been enhanced to include support for dynamic menu
	drawing for submenus (only). To use this mode, we don't create a whole
	array of menu_item_t to hold the entire menu. Instead, we provide a
	function that can draw on the screen a single menu item, from our own
	local data structures, given just the item index. That drawing function
	has to support two modes, DRAW_EVERYTHING and DRAW_UPDATES. In the first
	mode, it can assume that the area has already been cleared out, and it
	has to draw everything that needs to appear. In UPDATES mode, it must
	assume that the item is already fully drawn, but maybe with outdated
	data. It should erase and redraw only those parts of the item that have
	changed, in order to minimize distracting screen flicker.

	In order to work with the dynamic submenu, we need two arrays. The
	sorted_list is as long as the neighbor list, but only contains the
	index of the corresponding entry in the main array (one byte per entry).
	It gets rebuilt only at controlled times. The other array,
	display_items_list, is only as long as the number of entries on a single
	screen (9). Each entry contains the index into the sorted_list, and all the
	info we need to save to keep track of what's already on screen. The
	address into display_items_list is the address into the sorted_list,
	modulo the number of items per screen. Thus we can re-use the nine entries
	to keep track of what's on screen, regardless of offset into sorted_list,
	since we know that the items on the screen are contiguous in sorted_list,
	and thus have sorted_list indexes that are distinct modulo 9.
	When sorted_list is rebuilt, display_items_list is emptied (that is, the
	index field is set to NEIGHBOR_NONE for every entry).

	So, when the menu routine calls for a DRAW_EVERYTHING on a given menu
	index, we look it up in sorted_list to get the info. We decide on the
	formatting and draw it at the specified coordinates on screen. Then we
	overwrite the index%screenlines entry of display_items_list with the
	index and all the data we displayed. Then a bit later, when the menu
	routine calls for a DRAW_UPDATES, we check display_items_list[index%screenlines]
	and verify that the index is what we expect. If it matches, we can compare
	the latest data for that neighbor to what's already on screen, as recorded
	in the display_items_list entry. If anything needs to be updated, we
	erase and update it on the screen, at whatever offset from the specified
	coordinates. Finally, we update the display_items_list entry. Whew.

	Sorted_list is rebuilt when the neighbor list is first chosen from the
	main menu. It can also be rebuilt on an arbitrary timer (say 10sec) as
	long as the screen is displaying the first record (offset zero). We don't
	want to update it automatically if the screen has been scrolled down,
	because that would be confusing. We also can rebuild it if the user
	attempts to scroll UP past the first entry. (Need to test and see if we
	need to lock this out for a while after each invocation. Rapid button taps
	might give ugly results.)

	The custom draw routine receives an index into sorted_list. For a
	DRAW_EVERYTHING call, it needs only the current info. The current info
	is available by following sorted_list[index] to the main array and
	accessing members of the entry there. For a DRAW_UPDATES call, it also
	needs the old displayed info. If available, that info is in the members
	of displayed_items_list[index%9]. Simple.

	The logic of the dynamic menu handler takes care of updating the fields
	if they change while displayed. If nothing else it going on, it just calls
	for DRAW_UPDATES on all the displayed items. This means RSSI changes and
	even name changes are displayed more or less as quickly as possible. Yay.


	once:
	fill sorted_list with NEIGHBOR_NONE

	each time:
	freeze neighbor updates
	scan through the neighbor list
		for each non-empty entry, put its index in the next position of sorted_list
	qsort sorted_list using a comparison function that looks up the
			pointed-to entries in the array and compares their RSSIs.
			Sort just the number of entries we've used so far.
	unfreeze updates to the array
	call mbp_submenu in dynamic menu mode


	[Need to add scroll-off-the-top handler to mbp_submenu]
	[Need to add dwell-at-the-top timer to mbp_submenu]


The action callback for the neighbor list menu goes like this:
	if the neighbor is not a Trans-Ionospheric,
		display an info screen that looks like this:
			BADGENAME

			type-of-badge-by-mfg-id

			BLE   00:11:22:33:44:55
			RSSI            -45 dBm
			Last Heard 00:00:05 ago

		no actions possible here, left key returns to neighbor list

	if the neighbor is a Trans-Ionospheric and we have not attempted a QSO
	with it before now,
		display an info screen that looks like this:
			BADGENAME

			Trans-Ionospheric

			BLE   00:11:22:33:44:55
			RSSI            -45 dBm
			Last Heard 00:00:05 ago

			QSO             CANCEL

		If the badge isn't accepting QSO game requests, replace the buttons
		with a message to that effect.

	if the neighbor is a Trans-Ionospheric and we have a QSO game file for it,
		display a menu screen:
			BADGENAME
			1) Info
			2) Search in Log
			3) QSO again

		Choosing 1 brings up a QSO info screen:
			BADGENAME

			BLE   00:11:22:33:44:55
			RSSI            -45 dBm
			Last Heard 00:00:05 ago

			CALLSIGN         WD5HFW
			QSOs                  1
			Messages              1

			no actions here, left key returns to the little menu.

		Choosing 2 shows the QSO game file in the log viewer. Exit to little menu.

		Choosing 3 attempts a QSO.

		If the badge isn't accepting QSO game requests, disable option 3 and
		replace the text with "Not accepting QSOs"



Helloing works like this:
	instead of triggering on a reception, it will trigger on a timer.
	details TBD

	We'd like to hello badges that turn on or walk by very close with low
	delay. We'd also like to hello badges that are more or less nearby, but
	some delay is OK in that case. We don't necessarily want to hello badges
	that are weak, like in the next room or out in the hall.

	on a timer expiration (10 seconds?):
		scan the neighbor list
			exclude badges we've already helloed
			exclude badges with last_heard more than 30 seconds ago
			pick the highest RSSI
		if the candidate RSSI is above threhold T1, hello it
		else if the candidate RSSI is above T2 and last_heard is fresh, hello it
		else if the candidate RSSI is above T3 and it has been 60 seconds
		since we helloed anybody, hello it

		every 10 minutes, randomly unmark somebody we've helloed
